const mongoose = reuire("mongoose");

const taskDependencySchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    dependentTask: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Task",
      required: true,
    },

    prerequisiteTasks: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Task",
      required: true,
    },

    dependencyType: {
      type: String,
      enum: [
        "finish_to_start", // prerequisite must finish before dependent can start
        "start_to_start", // prerequisite must start before dependent can start
        "finish_to_finish", // prerequisite must finish before dependent can finish
        "start_to_finish", // prerequisite must start before dependent can finish
        "blocks", // prerequisite blocks dependent (most common)
        "subtask_of", // dependent is a subtask of prerequisite
        "related", // loose relationship, for reference only
      ],
      default: "finish_to_start",
    },

    // Lag time between tasks (in minutes)
    lag: {
      type: Number,
      default: 0, // No delay
    },
    lead: {
      type: Number,
      default: 0,
    },
    strength: {
      type: String,
      enum: ["soft", "medium", "hard"],
      default: "medium",
    },

    isActive: {
      type: Boolean,
      default: true,
    },

    // Reason for Dependency

    reason: {
      type: String,
      trim: true,
    },
    // Auto-generated or manually created
    isAutoGenerated: {
      type: Boolean,
      default: false,
    },
    // Confidence score for auto-generated dependencies
    confidence: {
      type: Number,
      min: 0,
      max: 1,
      default: 1,
    },

    // Status tracking
    status: {
      type: String,
      enum: [
        "pending",
        "ready", // prerequisite completed, dependent can proceed
        "violated", // dependency rule was broken
        "resolved", // dependency relationship completed
        "suspended", // temporarily inactive
      ],
      default: "pending",
    },

    // Violation tracking
    violations: [
      {
        violationType: {
          type: String,
          enum: ["started_early", "completed_out_of_order", "ignored"],
        },
        violationDate: Date,
        description: String,
        resolved: {
          type: Boolean,
          default: false,
        },
      },
    ],

    // Impact metrics

    impact: {
      scheduleImpact: {
        type: String,
        enum: ["low", "medium", "high", "critical"],
        default: "medium",
      },

      estimatedDelay: Number,

      violationCost: {
        type: String,
        enum: ["low", "medium", "high"],
        default: "medium",
      },
    },

    // Conditional dependencies
    conditions: [
      {
        type: {
          type: String,
          enum: [
            "prerequisite_progress",
            "date_condition",
            "resource_available",
            "approval_received",
          ],
        },
        value: String, // condition value (e.g., "80" for 80% progress)
        operator: {
          type: String,
          enum: [
            "equals",
            "greater_than",
            "less_than",
            "greater_equal",
            "less_equal",
          ],
          default: "greater_equal",
        },
        met: {
          type: Boolean,
          default: false,
        },
      },
    ],

    // Resource Dependencies

    resourceDependencies: [
      {
        resourceType: {
          type: String,
          enum: ["person", "tool", "location", "approval", "information"],
        },

        resourceId: String,
        required: {
          type: Boolean,
          default: true,
        },
        available: {
          type: Boolean,
          default: false,
        },
      },
    ],

    // Automation Rules
    automation: {
      // Auto update dependent when task changes
      autoUpdate: {
        type: Boolean,
        default: true,
      },

      // Autonotify when dependent is ready

      autoNotify: {
        type: Boolean,
        default: true,
      },

      autoReschedule: {
        type: Boolean,
        default: false,
      },

      // Dependency chain information
      chainInfo: {
        level: Number,
        isCriticalPath: {
          type: Boolean,
          default: false,
        },
        totalChainLength: Number,
      },

      // Historical Data

      history: [
        {
          action: {
            type: String,
            enum: [
              "created",
              "modified",
              "activated",
              "deactivated",
              "violated",
              "resolved",
            ],
          },
          date: Date,
          details: String,
          user: {
            type: mongoose.Schema.Types.ObjectId,
            ref: "User",
          },
        },
      ],
    },
  },
  { timestamps: true }
);

//Indexes

taskDependencySchema.index({ user: 1, dependentTask: 1 });
taskDependencySchema.index({ user: 1, prerequisiteTask: 1 });
taskDependencySchema.index({ user: 1, isActive: 1 });
taskDependencySchema.index({ user: 1, status: 1 });
taskDependencySchema.index(
  { dependencyTask: 1, prerequisiteTask: 1 },
  { unique: true }
);

// Prevent circular dependencies
taskDependencySchema.pre("save", async function (next) {
  if (this.dependencyTask.toString() === this.prerequisiteTask.toString()) {
    return next(new Error("A task cannot depend on itself"));
  }

  // Check for circular dependencies
  const hasCircularDependency = await this.checkCircularDependency();

  if (hasCircularDependency) {
    return next(
      new Error("This dependency would create a circular dependency")
    );
  }

  next();
});

// Method for checking circular dependencies
taskDependencySchema.methods.checkCircularDependency = async function () {
  const visited = new Set();
  const recursionStack = new Set();

  const hasCycle = async (taskId) => {
    if (recursionStack.has(taskId.toString())) {
      return true;
    }

    if (visited.has(taskId.toString())) {
      return false;
    }

    visited.add(taskId.toString());
    recursionStack.add(taskId.toString());

    //get all prerequisites

    const dependencies = await this.model("TaskDependency").find({
      dependentTask: taskId,
      isActive: true,
    });

    recursionStack.delete(taskId.toString());
    return false;
  };

  return hasCycle(this.prerequisiteTask);
};

// Method to update dependency status
taskDependencySchema.methods.updateStatus = async function () {
  const Task = mongoose.model("Task");

  const prerequisiteTask = await Task.findById(this.prerequisiteTask);
  const dependentTask = await Task.findById(this.dependentTask);

  if (!prerequisiteTask || !dependentTask) {
    this.status = "violated";
    return this.save();
  }

  // Check conditions
  let conditionsMet = true;
  for (const condition of this.conditions) {
    switch (condition.type) {
      case "prerequisite_progress":
        const progress = prerequisiteTask.progress || 0;
        const required = parseInt(condition.value);
        condition.met = this.evaluateCondition(
          progress,
          condition.operator,
          required
        );
        break;
      case "date_condition":
        const now = new Date();
        const targetDate = new Date(condition.value);
        condition.met = this.evaluateCondition(
          now.getTime(),
          condition.operator,
          targetDate.getTime()
        );
        break;
    }

    if (!condition.met) {
      conditionsMet = false;
    }
  }

  // Update status based on dependency type and conditions
  switch (this.dependencyType) {
    case "finish_to_start":
    case "blocks":
      if (prerequisiteTask.completed && conditionsMet) {
        this.status = "ready";
      } else if (dependentTask.completed && !prerequisiteTask.completed) {
        this.status = "violated";
        this.violations.push({
          violationType: "completed_out_of_order",
          violationDate: new Date(),
          description: "Dependent task completed before prerequisite",
        });
      } else {
        this.status = "pending";
      }
      break;

    case "start_to_start":
      if (prerequisiteTask.progress > 0 && conditionsMet) {
        this.status = "ready";
      } else {
        this.status = "pending";
      }
      break;

    case "subtask_of":
      if (prerequisiteTask.completed) {
        this.status = "resolved";
      } else {
        this.status = "pending";
      }
      break;

    default:
      this.status = "pending";
  }

  return this.save();
};

// Helper method to evaluate conditions
taskDependencySchema.methods.evaluateCondition = function (
  actual,
  operator,
  expected
) {
  switch (operator) {
    case "equals":
      return actual === expected;
    case "greater_than":
      return actual > expected;
    case "less_than":
      return actual < expected;
    case "greater_equal":
      return actual >= expected;
    case "less_equal":
      return actual <= expected;
    default:
      return false;
  }
};

// Method to get all dependent tasks (recursively)
taskDependencySchema.statics.getDependentChain = async function (
  taskId,
  visited = new Set()
) {
  if (visited.has(taskId.toString())) {
    return []; // Prevent infinite loops
  }

  visited.add(taskId.toString());

  const dependencies = await this.find({
    prerequisiteTask: taskId,
    isActive: true,
  }).populate("dependentTask");

  let chain = dependencies.map((dep) => dep.dependentTask);

  // Recursively get dependent chains
  for (const dep of dependencies) {
    const subChain = await this.getDependentChain(
      dep.dependentTask._id,
      visited
    );
    chain = chain.concat(subChain);
  }

  return chain;
};

// Method to get all prerequisite tasks (recursively)
taskDependencySchema.statics.getPrerequisiteChain = async function (
  taskId,
  visited = new Set()
) {
  if (visited.has(taskId.toString())) {
    return []; // Prevent infinite loops
  }

  visited.add(taskId.toString());

  const dependencies = await this.find({
    dependentTask: taskId,
    isActive: true,
  }).populate("prerequisiteTask");

  let chain = dependencies.map((dep) => dep.prerequisiteTask);

  // Recursively get prerequisite chains
  for (const dep of dependencies) {
    const subChain = await this.getPrerequisiteChain(
      dep.prerequisiteTask._id,
      visited
    );
    chain = chain.concat(subChain);
  }

  return chain;
};

// Method to calculate critical path
taskDependencySchema.statics.calculateCriticalPath = async function (userId) {
  const Task = mongoose.model("Task");

  // Get all active tasks for user
  const tasks = await Task.find({ user: userId, completed: false });
  const dependencies = await this.find({ user: userId, isActive: true });

  // Build dependency graph
  const graph = {};
  const inDegree = {};

  // Initialize
  tasks.forEach((task) => {
    graph[task._id] = [];
    inDegree[task._id] = 0;
  });

  // Build graph and calculate in-degrees
  dependencies.forEach((dep) => {
    if (graph[dep.prerequisiteTask] && graph[dep.dependentTask]) {
      graph[dep.prerequisiteTask].push({
        task: dep.dependentTask,
        duration: dep.lag || 0,
      });
      inDegree[dep.dependentTask]++;
    }
  });

  // Calculate longest path (critical path)
  const distances = {};
  const queue = [];

  // Initialize distances and find starting nodes
  Object.keys(inDegree).forEach((taskId) => {
    distances[taskId] = 0;
    if (inDegree[taskId] === 0) {
      queue.push(taskId);
    }
  });

  // Topological sort with longest path calculation
  while (queue.length > 0) {
    const current = queue.shift();

    graph[current].forEach((neighbor) => {
      const newDistance = distances[current] + neighbor.duration;
      if (newDistance > distances[neighbor.task]) {
        distances[neighbor.task] = newDistance;
      }

      inDegree[neighbor.task]--;
      if (inDegree[neighbor.task] === 0) {
        queue.push(neighbor.task);
      }
    });
  }

  // Find critical path tasks
  const maxDistance = Math.max(...Object.values(distances));
  const criticalTasks = Object.keys(distances).filter(
    (taskId) => distances[taskId] === maxDistance
  );

  // Update critical path indicators
  await this.updateMany(
    { user: userId },
    { $set: { "chainInfo.isCriticalPath": false } }
  );

  for (const taskId of criticalTasks) {
    await this.updateMany(
      { $or: [{ dependentTask: taskId }, { prerequisiteTask: taskId }] },
      { $set: { "chainInfo.isCriticalPath": true } }
    );
  }

  return {
    criticalTasks,
    totalDuration: maxDistance,
    taskDistances: distances,
  };
};

// Method to suggest dependencies based on task content
taskDependencySchema.statics.suggestDependencies = async function (taskId) {
  const Task = mongoose.model("Task");
  const task = await Task.findById(taskId).populate("category tags");

  if (!task) return [];

  const suggestions = [];

  // Find tasks in the same category that might be prerequisites
  const categoryTasks = await Task.find({
    user: task.user,
    category: task.category,
    _id: { $ne: taskId },
    completed: false,
  });

  // Simple heuristics for suggesting dependencies
  categoryTasks.forEach((candidateTask) => {
    let score = 0;

    // Tasks with "setup", "prepare", "plan" are likely prerequisites
    if (/setup|prepare|plan|research|design/i.test(candidateTask.title)) {
      score += 0.3;
    }

    // Tasks with "implement", "execute", "build" are likely dependents
    if (
      /implement|execute|build|create|develop/i.test(task.title) &&
      /setup|prepare|plan|research|design/i.test(candidateTask.title)
    ) {
      score += 0.4;
    }

  
    const commonTags = task.tags.filter((tag) =>
      candidateTask.tags.some(
        (ctag) => ctag._id.toString() === tag._id.toString()
      )
    );
    score += commonTags.length * 0.1;

    if (score > 0.3) {
      suggestions.push({
        prerequisiteTask: candidateTask._id,
        dependentTask: taskId,
        confidence: Math.min(score, 1),
        reason: "Based on task titles and category similarity",
        isAutoGenerated: true,
      });
    }
  });

  return suggestions.sort((a, b) => b.confidence - a.confidence);
};

const TaskDependency = mongoose.model("TaskDependency", taskDependencySchema);

module.exports = TaskDependency;
